## 索引的基本原理

- *把创建了索引的列的内容进行排序*
- *对排序结果生成倒排表*
- *在倒排表内容上拼上数据地址链*
- *在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据*

## MySQL聚簇索引和非聚簇索引的区别

- 聚簇索引是InnoDB使用的索引类型，索引和数据都在同一个文件中。当进行索引列查询的情况下，找到对应索引时可以直接返回结果。
- 非聚簇索引是MyISAM使用的索引类型，索引和数据分别存放在两个文件中，查询时首先查询索引文件，在索引文件中获取对应内存位置，然后再在数据文件中查询结果并返回。

上面两条归类为：

- *都是B+树结构*
  - 聚簇索引，将数据存储于索引放到了一块，并且是按照一定的顺序组织的，找到索引也就找到了数据，数据的物理存放顺序于索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻存放在磁盘上的。
  - 非聚簇索引，叶子结点不存储数据，存储的是数据行地址，也就是说根据索引找到数据行的位置再取磁盘查找数据，类似于书的目录。
- *优势：*
  - *查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要二次查询效率要高。*
  - *聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的。*
  - *聚簇索引适合用在排序的场合，非聚簇索引不适合。*
- *劣势：*
  - *维护索引很昂贵，特别是插入新行或者主键被更新导致要分页的时候。在大量插入新行后，选在负载较低的时段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片。*
  - *表使用UUID作为主键，是数据存储稀疏，会出现聚簇索引可能比全表扫描更慢。推荐使用int的auto_increment作为主键。*
  - *如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值会导致非叶子结点占用更多的物理空间。*

## MySQL索引的数据结构，各自优劣

- 哈希：*采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立即定位到相应的位置，速度非常快。*
- B+树：B+树是一个平衡多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率很高。

## 索引设计的原则

- *适合索引的列是出现在where子句中的列，或者连接子句中指定的列*
- *基数较小的表，索引效果较差，没有必要在此建立索引*
- *使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。*
- *不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，时间越长。所以只保持需要的索引有利于查询即可。*
- *定义有外键的数据列一定要建立索引*
- *更新频繁字段不适合创建索引*
- *若是不能有效区分数据的列不适合做索引列（性别）*
- *尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，只需要修改原索引即可。*
- *对那些查询中很少涉及的列，重复值比较多的列不要建立索引。*
- *对于定义为text、image和bit的数据类型的列不要建立索引。*

## InnoDB存储引擎的锁的算法

- Record Lock：单个行记录上的锁
- Gap Lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key Lock：record+gap 锁定一个范围，包含记录本身
- innoDB对于行的查询使用next-key lock
- next-locking key为了解决Phantom Problem幻读问题。
- 当查询的索引含有唯一属性时，将next-key lock降级为record key
- gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
- 有两种方式显式关闭gap锁
  - 将事务隔离级别设置为RC
  - 将参数innodb_locks_unsafe_for_binlog设置为1

## 关心过业务系统里面的SQL耗时吗？统计过慢查询吗？对慢查询都怎么优化过？

- 首先分析语句，看看是否Load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

## 事务的基本特性和隔离级别

ACID

- 原子性，指的是一个事务中的操作要么全部成功，要么全部失败。
- 一致性，一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100元，假设A只有90元，支付前数据库的数据都是符合约束的。但是如果事务执行成功了，我们的数据库数据就破坏约束了，因此事务不能成功。
- 隔离性，指的是一个事务的修改在最终提交前，对其他事务时不可见的
- *持久性*，指的是一旦事务提交，所做的修改就会永久保存到数据库中

隔离级别

- 读未提交，read uncommit，可能会读到其他事务未提交的数据，也叫做脏堵。
- 读提交，read commit，两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。
- 可重复读，mysql的默认级别，每次读取的结果都是一样，但是有可能产生幻读。
- Seralizable，一般不会使用，会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

## 分表后非sharding_key的查询怎么处理，分表后的排序？



## MySQL主从同步原理

- 主节点binlog，主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。
- 主节点log dump线程，当binlog有变动时，log dump现成读取其内容并发送给从节点。
- 从节点IO线程接收binlog内容，并将其写入到relay log文件中。
- 从节点的SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性。

## 简述MyISAM和InnoDB的区别

- 是否支持事务：InnoDB支持ACID事务，支持事务的四种隔离级别。MyISAM不支持事务，但是每次查询都是原子的。
- 锁类型：InnoDB支持行级锁及外键约束，因此可以支持写并发；MyISAM支持表级锁，每次操作对整个表加锁。
- 是否存储总行数：InnoDB不存储总行数，MyISAM存储总行数
- 本地持久化文件：InnoDB存储在一个文件空间，MyISAM有三个文件：索引文件，表结构文件，数据文件
- 索引类型：InnoDB采用聚簇索引，最好使用自增主键，防止插入数据时索引结构大调整。MyISAM采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。

## 简述Mysql中索引类型及对数据库性能的影响

- 普通索引：允许被索引的数据列包含重复的值
- 唯一索引：可以保证数据记录的唯一性。
- 主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字Primary KEY来创建。
- 联合索引：索引可以覆盖多个数据列
- 全文索引：通过建立'倒排索引'，可以极大提升检索效率，解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT(column)创建全文索引。

## Explain语句结果中各个字段分别表示什么

- Id：查询语句中每出现一个SELECT关键字，MySQL就会为它分配一个唯一的id值，某些子查询会被优化为join查询，那么出现的id会一样。
- select_type：SELECT关键字对应的那个查询的类型
- Table：表名
- Partitions:匹配的分区信息
- Type：针对单表的查询方式（全表扫描、索引）
- possible_keys：可能用到的索引
- Key：实际上使用的索引
- key_len：实际使用到的索引长度
- Ref：当前使用索引列等值查询时，与索引列进行等值匹配的对象信息
- Rows：预估的需要读取的记录条数
- Filtered：某个表经过搜索条件过滤后剩余记录条数的百分比
- extra：一些额外的信息，比如排序等

## 索引覆盖是什么

- 索引覆盖就是一个SQL在执行时，可以利用索引来快速查找，并且此SQL所要查询的字段在当前索引对应的字段都包含了，那么就表示此SQL走完索引后不用回表了，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回了。

## 最左前缀原则是什么

- 在联合索引中，查询语句的where条件匹配要从最左前缀开始匹配。
- 也就是说where字段的顺序是联合索引的顺序。
- 如果最左前缀的字段没有匹配，就无法使用联合索引。
- 还有一点，要从联合索引的结构来讲
- 因为联合索引的结构是以建立联合索引的第一个字段作为B+树节点插入，如果没有匹配到最左字段，那么联合索引中的值是无序的，查询更花费时间。

## InnoDB是如何实现事务的

- 有一个回滚日志，“rollback log”
- 当操作发生异常时，通过回滚日志，将数据库回滚到这次事务操作之前。

正解：

- InnoDB在收到一个update语句后，会先根据条件找到数据所在的页，并将该页缓存在Buffer Pool中。
- 执行update语句，修改Buffer Pool中的数据，也就是内存中的数据。
- 针对update语句生成一个RedoLog对象，并存入LogBuffer中
- 针对Update语句生成undoLog日志，用于事务回滚
- 如果事务提交，那么则把RedoLog对象进行持久化，后续还有其他机制将Buffer Pool中所修改的数据页持久化到磁盘中
- 如果事务回滚，则利用undoLog日志进行回滚

## B树和B+树的区别，为什么Mysql使用B+树

- B树
  - 节点排序
  - 一个节点可以存多个元素，多个元素也排序了
- B+树
  - 拥有B树的特点
  - 叶子节点之间有指针
  - 非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序
- MySQL索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在MySql中一个InnoDB页就是一个B+树节点，一个InnoDB页默认16kb，所以一般情况下一颗两层B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。

## Mysql锁有哪些，如何理解

- 行锁：锁某行数据，锁粒度最小，并发度高
- 表锁：锁整张表，锁粒度最大，并发度低
- 间隙锁：锁的是一个区间
- 共享锁：也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写
- 排它锁：也就是写锁，一个事务给某行数据接了写锁，其他事务不能读，也不能写
- 乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的
- 悲观锁：上面的行锁、表锁等都是悲观锁

## Mysql慢查询该如何优化？

- 检查是否走了索引，如果没有则优化SQL利用索引
- 检查所利用的索引，是否是最优索引
- 检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据
- 检查表中数据是否过多，是否应该进行分库分表了
- 检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源