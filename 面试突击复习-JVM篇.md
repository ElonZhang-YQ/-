## JVM有哪些类加载器

- BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%lib下的jar包和class文件
- ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和class类
- AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件

## 说说类加载器双亲委派模型

- JVM在加载一个类时，会调用AppClassLoader的loadClass方法来加载这个类，不过在这个方法中，会先试用ExtClassLoader的loadClass方法来加载类，同样ExtClassLoader的loadClass方法中会使用BootStrapClassLoader来加载类
- 如果BootStrapClassLoader加载到了就直接成功，如果BootStrapClassLoader没有加载到，那么ExtClassLoader就会自己尝试加载该类，如果没有加载到，那么则会用AppClassLoader来加载这个类
- JVM在加载类时，会委派给Ext和BootStrap进行加载，如果没有加载到才由自己进行加载。

## GC如何判断对象可以被回收

- 引用计数法，每个对象都有一个引用计数器，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。
- 可达性分析法，从GC Roots开始向下搜索，搜索所走过的路径成为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。
  - GC Roots的对象有：
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区常量引用的对象
    - 本地方法栈中JNI（一般说Native方法）引用的对象

## JVM内存模型

- 程序计数器
- 本地方法栈
- 虚拟机栈
- 方法区/元空间
- 堆内存

## JVM参数有哪些？

- 标注指令，-开头，这些是所有HotSpot都支持的参数，可以用java -help打印出来
- 非标准指令，-X开头，通常是跟特定的HotSpot版本对应的，可以用java -x打印出来
- 不稳定参数，-XX开头，这一类参数是跟特定HotSpot版本对应的，变化非常大

## JVM有哪些垃圾回收算法？

- 标记-清除，把垃圾内存标记出来，然后将标记的清理掉。会产生大量的内存碎片。
- 标记-整理（压缩），为了解决复制算法的缺陷，首先标记和标记清除算法一样，标记完成后，将存活对象往一段移动，然后将端边界以外的所有内存直接清除。
- 复制，将内存分为大小相等的两半，每次只使用一半。垃圾回收前，将这一块存活的对象全部拷贝到另一半，然后这一半内存就可以直接清除。但是浪费空间

## JVM有哪些垃圾回收器？

- 新生代收集器
  - Serial
  - ParNew
  - Parallel Scavenge
- 老年代收集器
  - CMS
  - Serial Old
  - Parallel Old
- 整堆收集器，G1

## 垃圾回收分为哪些阶段

- 初始标记，标记出GCRoot直接引用的对象 STW
- 标记Region，通过RSet标记出上一个阶段标记的Region引用到的Old区Region
- 并发标记阶段，跟CMS的步骤是差不多的。只是遍历的范围不再是整个Old区，而只需要遍历第二步标记出来的Region
- 重新标记，跟CMS中的重新标记过程是差不多的
- 垃圾清理，与CMS不同的是，G1可以采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region。这个阶段G1只选择垃圾较多的Region来清理，并不是完全清理。

## 什么是STW？

- Stop the World
- JVM在进行垃圾回收的时候，会停止垃圾回收之外的线程。
- 原因：为了避免在垃圾回收的过程中，有对象被标记为垃圾，但是没有被及时处理。
- GC调优的重点就是减少STW

## 什么是三色标记？

- 黑色，表示自己和成员变量都已经标记完毕
- 灰色，自己标记完了，但是成员变量还没有完全标记
- 白色，自己未标记完

## 一个对象从加载到JVM，再到被GC清除，都经历了什么过程？

- 用户创建一个对象，JVM首先要到方法区去找对象的类型信息，然后再创建对象
- JVM要实例化一个对象，首先要在堆中先创建一个对象
- 对象首先会分配在堆内存中新生代的Eden，然后经历过一次Minor GC，对象如果存活，就就会进入S区。在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1。默认值15，会进入老年代。
- 当方法执行结束后，栈中的指针会先移除掉
- 堆中的独享，经过Full GC，就会被标记为垃圾，然后被GC线程清理掉。

## 如何排查JVM问题？

- 正常运行的系统
  - 使用jmap来查看JVM中各个区域的使用情况
  - 可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁
  - 可以通过jstat命令查看垃圾回收的情况，特别是fullgc，如果发现了fullgc比较频繁，那么就得进行调优了
  - 通过各个命令的结果，或者jvisualvm等工具来进行分析
  - 首先，初步猜测频繁发送fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，那么这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入老年代，尝试加大年轻代的打下哦，如果改完之后，fullgc减少，证明修改有效。
  - 同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存。
- 已经OOM的系统
  - 一般生产系统中都会设置当系统发生OOM时，生成当时的dump文件
  - 利用jsisualvm等工具来分析dump文件
  - 根据dump文件找到异常的实例对象，和异常的线程（占用CPU高），定位到具体的代码
  - 然后再进行详细的分析和调试