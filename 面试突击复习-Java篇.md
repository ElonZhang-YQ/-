## JDK、JRE和JVM之间的区别

- JDK是Java Develop Kit，是Java程序开发的环境

- JRE是Java Runtime Environment，java运行时环境。所有java程序需要安装JRE才可以运行。

- JVM是Java Virtual Machine，是Java的虚拟机，所有的字节码文件都运行在Java虚拟机中

## 面向对象的三大特点，详细描述一下

- 封装，将对象所有的信息封装起来，避免外部进行修改。如果需要进行修改，只需要暴露出修改方法即可，而不是暴露出对应的属性。*外部属性无需修改或者关心内部实现* 。
- 继承，子类可以继承父类的属性和方法，子类可以基于父类做出一定的修改和私有的定制。
- 多态，相同接口的情况下，会有不同的实现方式，具体实现的逻辑不同。

## ==和equals方法之间的区别

- 对于基本类型来说，== 比较的是值，equals比较的也是值。

- 对于复杂类型来说，==比较的是对应JVM中内存的地址，equals比较的是值是否相同。

## hashCode()与equals()之间的关系

- object对象在进行equals()比较的时候，首先通过hashCode()判断对应的哈希码是否相同。扩展：如果两个对象的hashCode()相同，并不代表两个对象相同，需要具体判断equals()方法中属性值是否相同。

## final关键字的作用是什么？

#### final关键字可以修饰哪些？

- 类，final关键字修饰类的情况，表明这个类是不可继承，不可修改的类，例如String类
- 方法，final关键字修饰方法的情况下，表明这个方法不可以被覆盖，但是可以重载。
- 变量，final关键字修饰属性的情况下，表明这个变量是不可修改的。
- **引用对象** ，*如果是基本数据类型，初始化之后不可修改。如果是引用类型的变量，初始化之后不能指向其他变量，但是引用变量的值是可变的*。



## String、StringBuffer和StringBuilder的区别

- String是不可变类，在声明之后，长度是无法修改的。
- StringBuffer和StringBuilder是可以用作拼接字符串，不过StringBuffer是线程安全的，单线程环境下StringBuilder效率更高一些（10%）。通过调用toString()方法生成字符串。通过append(str)去拼接字符串。

## 重载和重写的区别

- 方法重载发生在同一个类中，对象的构造方法可以有多个不同参数的实现，**方法名相同，参数类型不同，参数个数不同。**这个叫做方法重载。
- 方法重写发生在继承关系中，子类对象可以对父类方法进行重写，**方法名、参数列表都相同**。进行自定义的定制。

## 接口和抽象类的区别

- 数量不同，一个对象只能继承一个抽象类，但是可以实现多个接口
- 是否有构造方法，接口没有构造方法，抽象类可以有构造方法。
- 是否有变量，接口只能定义常量，抽象类可以定义变量。
- 是否有成员函数，抽象类可以有普通方法，但是接口只能定义接口方法。

## List和Set的区别

- 是否有序，List是有序的，Set是无序的
- 元素是否唯一，Set是唯一的，List不是唯一的，可以有重复值。
- 允许NULL，List允许多个NULL值，Set只允许一个NULL值。
- *获取元素，List可以通过Iterator取出元素，也可以通过get(index)取出元素。Set只能通过Iterator取出元素*

## ArrayList和LinkedList区别

- 底层实现不同，ArrayList底层实现是数组的实现；LinkedList底层是链表实现。
- 是否实现随机访问，ArrayList实现了RandomAccess接口，可以实现随机访问。LinkedList没有实现，不支持随机访问。
- 内存地址是否连续，ArrayList内存地址是连续的；LinkedList的内存地址是不连续的。
- 线程是否安全，都是线程不安全的。

## HashMap和HashTable有什么区别？其底层实现是什么？

- 是否线程安全，HashMap是线程不安全的，HashTable是线程安全的，因为每一步操作都加了锁。
- HashMap的底层实现是数组+链表。在JDK1.8中改为数组+链表+红黑树。当链表长度大于8，且数组长度小于64的情况下，首先进行数组扩容。如果数组长度大于等于64，则将链表转换为红黑树。进行优化查询。
- HashTable底层实现就是HashMap，也是使用数组+链表的形式。虽然线程安全，但是效率较低，并发情况下使用ConcurrentHashMap。
- *计算key的Hash值，二次Hash对数组长度取模，对应到数组下标。如果没有产生Hash冲突，先进性equal比较，相同则取代该元素。不同则插入链表。如果没有产生Hash冲突，直接创建Node存入数组*

## 谈谈ConcurrentHashMap的扩容机制

- JDK1.7的情况下，ConcurrentHashMap里面是多个sagement，在ConcurrentHashMap创建时，sagement的数量已经固定无法修改。**每个sagement**相当于一个小型的HashMap。**扩容操作也是每一个sagement内部自行判断**。当进行扩容时，sagement中的table进行扩容。扩容之后，将原table中的元素进行reHash操作，在sagement中重新找到下标插入。
- JDK1.8的情况下，ConcurrentHashMap中不存在sagement，也就是说整个map就是一个sagement。*当某一个线程进行put操作时，发现ConcurrentHashMap正在扩容，那么该线程一起进行扩容操作。如果没有扩容操作时，将key-value加入map中，判断是否超过了阈值。扩容操作也是先生成一个新的数组，在转移元素时，将原数组分组，交给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作。*

## JDK1.7到JDK1.8 HashMap底层发生了什么变化？

- JDK1.7中，HashMap底层是由数组+链表的形式组成，并且使用*头插法*进行元素插入。
- 在JDK1.8中，HashMap底层改由数组+链表+红黑树的形式构成，当数组长度小于8，或者数组长度大于8且链表长度小于64的情况下，是数组+链表的形式。当链表的长度大于等于64时，链表会转换成红黑树，以便于搜索优化。同时，将*头插法改为尾插法，因为1.8中插入key-value时需要判断链表元素个数，需要遍历链表统计元素个数，正好使用尾插法*。
- *1.7的哈希算法比较复杂，总共扰动了4次。在JDK1.8中进行了简化，只需要扰动两次就可以完成哈希*

## 说一下HashMap的put方法

- *通过哈希算法算出key的数组下标*
- *如果下标位置元素为空，则将key-value封装为entry对象（JDK1.8为Node对象）放入该位置。*
- *如果下标不为空*
  - *JDK1.7的情况下首先判断是否需要扩容，如果需要扩容就先进行扩容操作。如果不扩容就生成entry对象，通过头插法添加到对应的链表中*
  - *JDK1.8的情况下，判断当前位置上Node的类型，如果是红黑树Node，就封装成Node添加到红黑树中。如果存在key，则更新value。如果是链表，就分装成Node通过尾插法添加到链表中（如果存在则替换值）。添加到链表或者红黑树中，判断是否需要扩容，如果需要扩容就扩容。不需要就结束Put方法*

## 泛型中extends和super的区别

- extends是定义了泛型的上限，泛型中所有的类都只能是这个类或者这个类的子类。
- super定义了泛型的下限，泛型中所有的类都只能是这个类或者这个类的父类，或者父类的父类往上。

## 深拷贝和浅拷贝

- 深拷贝，深拷贝会拷贝实例对象的地址，生成新的地址。如果是基本数据类型就拷贝值。
- 浅拷贝，浅拷贝出来的实例对象地址还是之前的地址，相当于拷贝出来的对象和原对象都是指向同一块内存。

## HashMap的扩容机制原理

- *JDK1.7版本*
  - *先生成新数组*
  - *遍历老数组中的每个位置上的链表的每个元素*
  - *取每个元素的key，并基于新数组长度计算出每个元素在新数组的下标*
  - *将元素添加到新数组中去*
  - *元素完全转移之后，将table指向新数组*
- *JDK1.8版本*
  - *先生成新数组*
  - *遍历老数组中的每个位置上的链表或者红黑树*
  - *如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去*
  - *如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素在新数组对应的下标位置。同时统计每个下标位置的元素个数，如果该下标位置的元素个数超过8，则生成新的红黑树，并将根节点添加到新数组的对应位置。如果不超过8，则生成链表，将链表的头结点添加到新数组的对应位置。*

## CopyOnWriteArrayList的底层原理是怎样的

- CopyOnWriteArrayList的底层还是使用数组的形式创建。
- *CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组进行，读操作在原数组进行*
- *写操作会进行加锁，写操作结束后会将原数组指向新数组*

## 什么是字节码？采用字节码的好处是什么？

- Java编译出来的.class文件就是字节码文件
- 采用字节码的好处是，不同平台下，不同标准下的java虚拟机都可以按照当前的环境进行.class文件的读取加载。
- Write once, run anywhere

## Java中的异常体系是怎样的

- Java中所有的异常基类是Throwable类
- 从Error中细分出Exception和Error类
- Error会导致程序被迫停止
- Exception分为RuntimeException运行时异常和CheckedException检查异常。RuntimeException发生在程序运行中，会导致当前线程执行失败。CheckedException发生在编译过程中，导致程序编译不过。